= üöÄ Potencia tu Terminal: Entradas, Salidas y Redirecci√≥n en Linux
:author: Alex Callejas
:doctype: article
:revdate: Oct 7, 2025
:keywords: stdin, stdout, stderr, pipes

image::images/portada_5.png[Entradas, salidas y Redirecci√≥n en Linux]

Si alguna vez has trabajado en la terminal de Linux, ya sea prepar√°ndote para un examen de certificaci√≥n como *LPIC-1*, *LFCS* o *RHCSA*, o simplemente administrando sistemas, habr√°s notado que los comandos no solo ejecutan tareas, sino que tambi√©n _interact√∫an_ contigo y con el sistema. Entender c√≥mo fluye la informaci√≥n ‚Äîlas *Entradas*, *Salidas* y la *Redirecci√≥n*‚Äî es fundamental para ser un administrador de sistemas eficiente.

== üí° El Flujo de Datos Est√°ndar: Stdin, Stdout y Stderr

En el coraz√≥n de la interacci√≥n de la terminal est√°n tres flujos de datos esenciales. Imag√≠nalos como tuber√≠as que conectan los programas.

[cols="1,1,2,5"]
|===
|Flujo |Descriptor |Nombre T√©cnico |Descripci√≥n

|*Entrada Est√°ndar* |*0* |`stdin` (Standard Input) |Es el canal por donde un programa espera recibir datos. Por defecto, es el *teclado*.
|*Salida Est√°ndar* |*1* |`stdout` (Standard Output) |Es el canal por donde un programa env√≠a sus resultados normales y esperados. Por defecto, es la *pantalla* (terminal).
|*Error Est√°ndar* |*2* |`stderr` (Standard Error) |Es el canal por donde un programa env√≠a mensajes de error o diagn√≥stico. Por defecto, tambi√©n es la *pantalla*.
|===

Todo comando que ejecutas en Linux utiliza (o puede utilizar) estos tres flujos. Saber manejarlos nos da un control tremendo sobre d√≥nde va a parar la informaci√≥n.

---

== üîÅ Redirecci√≥n: Controlando el Destino de los Datos

La redirecci√≥n nos permite cambiar los destinos por defecto de los flujos de salida (`stdout` y `stderr`) y el origen de la entrada (`stdin`).

=== Redirecci√≥n de Salida (Stdout)

En lugar de que el resultado normal de un comando se muestre en pantalla, podemos enviarlo a un archivo.

[cols="1,2,2,4"]
|===
|S√≠mbolo |Acci√≥n |Ejemplo |Descripci√≥n

|`>` |*Sobreescribe* (Overwrite) |`ls -l > lista.txt` |Ejecuta `ls -l` y *crea o reemplaza* el contenido de `lista.txt` con el resultado.
|`>>` |*A√±ade* (Append) |`date >> lista.txt` |Ejecuta `date` y *a√±ade* el resultado al final de `lista.txt`.
|===

=== Redirecci√≥n de Errores (Stderr)

Para separar los mensajes de error de los resultados normales y del *log* principal del sistema, utilizamos el descriptor *2*.

[cols="1,2,3,4"]
|===
|S√≠mbolo |Acci√≥n |Ejemplo |Descripci√≥n

|`2>` |Redirecciona solo *Stderr (2)* |`find / -name "noexiste" 2> errores.log` |Los mensajes de error de `find` van a `errores.log`. La salida normal (si la hubiera) sigue en pantalla.
|`2>` |Redirecciona solo *Stderr (2)* |`find / -name "miarchivo.txt" 2>/dev/null` |Los mensajes de error de `find` (como permisos denegados) se descartan al enviar la salida de errores al archivo especial /dev/null. Esto permite mostrar c√≥mo se pueden ocultar los errores de un comando, algo muy √∫til cuando buscas archivos por todo el sistema y no quieres que los mensajes de error llenen tu terminal.
|`2>>` |A√±ade solo *Stderr (2)* |`find / -name "noexiste" 2>> errores.log` |A√±ade los errores al final del archivo.
|===

=== Redirecci√≥n de Ambas Salidas: Stdout y Stderr

A menudo, queremos enviar *tanto la salida normal como los errores* al mismo archivo. Para esto, usamos el atajo `&>`.

[cols="1,2,2,4"]
|===
|S√≠mbolo |Acci√≥n |Ejemplo |Descripci√≥n

|`&>` |Redirecciona *Stdout (1) y Stderr (2)* |`comando &> todo.log` |La salida normal y los errores van juntos a `todo.log`. (Tambi√©n se puede usar `comando > todo.log 2>&1`).
|===

---

== ‚öôÔ∏è Tuber√≠as (Pipes): Conectando Comandos

La *tuber√≠a* o *pipe* (`|`) es uno de los conceptos m√°s poderosos y usados en la administraci√≥n de Linux. Permite tomar la `stdout` *(1)* de un comando y usarla como la `stdin` *(0)* del siguiente comando.

En esencia, est√°s *encadenando* la ejecuci√≥n, transformando datos paso a paso.

image::images/pipes.png[]

=== Ejemplo Pr√°ctico de Pipe

Imagina que quieres saber *cu√°ntos archivos de configuraci√≥n* (`.conf`) tienes en el directorio actual. Ejecuta:

[source,bash]
----
$ ls -l | grep ".conf" | wc -l
----

1. `ls -l`: Lista detallada de archivos (Stdout).
2. `| grep ".conf"`: La lista anterior se convierte en la entrada de `grep`, que filtra las l√≠neas que contienen ".conf" (`stdout`).
3. `| wc -l`: La lista filtrada se convierte en la entrada de `wc -l` (word count - lines), que simplemente *cuenta el n√∫mero de l√≠neas* resultantes y muestra el total.

¬°Con un solo *pipe* transformaste una lista de archivos en un simple n√∫mero!

---

== üîó Encadenamiento de Comandos: Ejecuci√≥n Condicional

El *pipe* conecta comandos por el flujo de datos. El *encadenamiento* conecta comandos por la *ejecuci√≥n*, permiti√©ndote controlar si un comando debe ejecutarse solo despu√©s de que el anterior haya tenido √©xito.

Esto se basa en el *c√≥digo de salida* (exit code) de cada comando:

* Un c√≥digo de salida de `0` significa que el comando se ejecut√≥ *con √©xito*.
* Un c√≥digo de salida *distinto de* `0` significa que hubo un *fallo*.

[cols="1,2,4,2"]
|===
|Operador |Nombre |Acci√≥n |Ejemplo

|`;` |Separador |Ejecuta los comandos *secuencialmente*, sin importar el √©xito del anterior. |`mkdir nuevo; cd nuevo; pwd`
|`&&` |AND L√≥gico |Ejecuta el segundo comando *solo si* el primero fue exitoso (`c√≥digo de salida = 0`). |`ping -c 1 8.8.8.8 && echo "Conexi√≥n OK"`
|===

El uso de `&&` y `||` es crucial para crear *scripts* robustos donde no quieres que un paso cr√≠tico se ejecute si la preparaci√≥n anterior fall√≥ (por ejemplo, no intentes copiar un archivo si la descarga fall√≥).

== Resumen y Pr√≥ximos Pasos

Dominar la redirecci√≥n y las tuber√≠as no es solo un requisito para aprobar el RHCSA o el LPIC-1; es la habilidad que te permite *automatizar, depurar y procesar* datos de manera eficiente como un verdadero profesional de Linux.

*¬°Tu Turno!* Intenta practicar encadenando comandos para:

1. Ver el espacio libre en disco.
2. Filtrar solo la l√≠nea que contiene el total.
3. Guardar ese resultado en un archivo llamado `disco_hoy.txt`.

¬°Hasta la pr√≥xima publicaci√≥n! üëã

// Enlace de la publicaci√≥n original (para versiones fuera de GitHub)
// link:https://www.rootzilopochtli.com/entradas-salidas-y-redireccion [Publicaci√≥n Original del Blog]

---

=== üìù Nota sobre Licencias y Contribuci√≥n:

Como anunciamos previamente en nuestra link:https://x.com/rootzilopochtli[cuenta de X], todo el contenido de nuestros posts e im√°genes se comparte bajo la licencia *CC BY-SA 4.0*. El c√≥digo de ejemplo, cuando sea aplicable, se licencia bajo la *MIT License*.

Adem√°s, hemos habilitado las discusiones en nuestro repositorio de GitHub para fomentar la colaboraci√≥n y el intercambio de conocimientos. ¬°Te invitamos a participar!

Puedes encontrar el anuncio original en X aqu√≠: link:https://x.com/rootzilopochtli/status/1974971692582850952[].

---

== Invitaci√≥n a la Comunidad üöÄ

Este *post* forma parte de una serie dedicada a la arquitectura y administraci√≥n de sistemas Linux. ¬°Queremos construir el mejor recurso posible *con tu ayuda*!

Te invitamos a:

* *Clonar el Repositorio:* El c√≥digo fuente de todos nuestros art√≠culos est√° disponible en *GitHub*.
* *Contribuir:* Si encuentras alg√∫n error, tienes sugerencias para mejorar la claridad de los conceptos o deseas proponer correcciones t√©cnicas, no dudes en enviar un *Pull Request* (Solicitud de extracci√≥n).
* *Comentar:* ¬øTienes una pregunta o un punto de vista diferente sobre alg√∫n concepto? Abre un *Issue* (Incidencia) en el repositorio para iniciar la discusi√≥n.

Tu colaboraci√≥n es vital para mantener este contenido preciso y actualizado.

*¬°Encuentra el repositorio y participa aqu√≠:* link:https://github.com/rootzilopochtli/introduccion-a-linux[github.com/rootzilopochtli/introduccion-a-linux]